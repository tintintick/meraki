{{ 'meraki-move-effect.css' | asset_url | stylesheet_tag }}

<div class="meraki-move-effect design-scale" data-section-id="{{ section.id }}">
  <div class="move-effect-container">
    <!-- Content (Title & Description) -->
    <div class="move-effect-content">
      <!-- Title -->
      <h2 class="move-effect-title">{{ section.settings.title | default: "Streamlined Workflow\nOn Screen" }}</h2>

      <!-- Description -->
      <p class="move-effect-description">{{ section.settings.description | default: "Start-to-finish coffee experience, with Meraki delivering a seamless workflow in every cup." }}</p>
    </div>

    <!-- Machine Container -->
    <div class="move-effect-machine-container">
      <picture>
        <source media="(min-width: 990px)" srcset="{{ section.settings.machine_image_desktop | default: 'move_effect/machine-pc.png' | asset_url }}">
        <img
          class="move-effect-machine"
          src="{{ section.settings.machine_image_mobile | default: 'move_effect/machine-mb.png' | asset_url }}"
          alt="Meraki Coffee Machine"
          loading="lazy"
        >
      </picture>
    </div>

    <!-- UI Circles -->
    <div class="move-effect-circles">
      <!-- Circle 1 -->
      <div class="move-effect-circle" data-circle="1">
        <img src="{{ 'move_effect/1.png' | asset_url }}" alt="UI Circle 1" loading="lazy">
      </div>

      <!-- Circle 2 -->
      <div class="move-effect-circle" data-circle="2">
        <img src="{{ 'move_effect/2.png' | asset_url }}" alt="UI Circle 2" loading="lazy">
      </div>

      <!-- Circle 3 -->
      <div class="move-effect-circle" data-circle="3">
        <img src="{{ 'move_effect/3.png' | asset_url }}" alt="UI Circle 3" loading="lazy">
      </div>

      <!-- Circle 4 -->
      <div class="move-effect-circle" data-circle="4">
        <img src="{{ 'move_effect/4.png' | asset_url }}" alt="UI Circle 4" loading="lazy">
      </div>

      <!-- Circle 5 -->
      <div class="move-effect-circle" data-circle="5">
        <img src="{{ 'move_effect/5.png' | asset_url }}" alt="UI Circle 5" loading="lazy">
      </div>

      <!-- Circle 6 -->
      <div class="move-effect-circle" data-circle="6">
        <img src="{{ 'move_effect/6.png' | asset_url }}" alt="UI Circle 6" loading="lazy">
      </div>

      <!-- Circle 7 -->
      <div class="move-effect-circle" data-circle="7">
        <img src="{{ 'move_effect/7.png' | asset_url }}" alt="UI Circle 7" loading="lazy">
      </div>

      <!-- Circle 8 -->
      <div class="move-effect-circle" data-circle="8">
        <img src="{{ 'move_effect/8.png' | asset_url }}" alt="UI Circle 8" loading="lazy">
      </div>

      <!-- Circle 9 -->
      <div class="move-effect-circle" data-circle="9">
        <img src="{{ 'move_effect/9.png' | asset_url }}" alt="UI Circle 9" loading="lazy">
      </div>

      <!-- Circle 10 -->
      <div class="move-effect-circle" data-circle="10">
        <img src="{{ 'move_effect/10.png' | asset_url }}" alt="UI Circle 10" loading="lazy">
      </div>

      <!-- Circle 11 -->
      <div class="move-effect-circle" data-circle="11">
        <img src="{{ 'move_effect/11.png' | asset_url }}" alt="UI Circle 11" loading="lazy">
      </div>

      <!-- Circle 12 -->
      <div class="move-effect-circle" data-circle="12">
        <img src="{{ 'move_effect/12.png' | asset_url }}" alt="UI Circle 12" loading="lazy">
      </div>

      <!-- Circle 13 -->
      <div class="move-effect-circle" data-circle="13">
        <img src="{{ 'move_effect/13.png' | asset_url }}" alt="UI Circle 13" loading="lazy">
      </div>

      <!-- Circle 14 -->
      <div class="move-effect-circle" data-circle="14">
        <img src="{{ 'move_effect/14.png' | asset_url }}" alt="UI Circle 14" loading="lazy">
      </div>

      <!-- Circle 15 -->
      <div class="move-effect-circle" data-circle="15">
        <img src="{{ 'move_effect/15.png' | asset_url }}" alt="UI Circle 15" loading="lazy">
      </div>
    </div>

    <!-- Bottom Gradient Mask -->
    <div class="move-effect-bottom-mask">
      <picture>
        <source media="(min-width: 990px)" srcset="{{ section.settings.mask_image_desktop | default: 'move_effect/machine-gradient-pc.png' | asset_url }}">
        <img
          src="{{ section.settings.mask_image_mobile | default: 'move_effect/machine-gradient-mb.png' | asset_url }}"
          alt="Gradient Mask"
          loading="lazy"
        >
      </picture>
    </div>
  </div>
</div>

<script>
(function() {
  function initMoveEffect() {
    const section = document.querySelector('[data-section-id="{{ section.id }}"]');
    if (!section) {
      setTimeout(initMoveEffect, 100);
      return;
    }

    // Get all elements to animate
    const circles = section.querySelectorAll('.move-effect-circle');
    const machineContainer = section.querySelector('.move-effect-machine-container');
    const contentContainer = section.querySelector('.move-effect-content');
    
    let accumulatedScroll = 0;
    const totalScrollDistance = 500; // 单次滑动推进更多动画（速度提升60%）
    
    // Smooth animation state
    let currentProgress = 0; // Current animated progress
    let targetProgress = 0; // Target progress from scroll
    let animationFrameId = null;
    const smoothFactor = 0.15; // Interpolation speed (0-1, higher = faster)
    
    // One-time animation state
    let animationCompleted = false; // Track if animation has been completed once

    // Check if desktop
    function isDesktop() {
      return window.innerWidth >= 990;
    }
    
    // Get scale factor
    function getScaleFactor() {
      const desktop = isDesktop();
      const varName = desktop ? '--scale-factor-desktop' : '--scale-factor-mobile';
      const value = getComputedStyle(section).getPropertyValue(varName).trim();
      const parsed = parseFloat(value);
      
      if (isNaN(parsed) || !parsed) {
        const screenWidth = window.innerWidth;
        if (desktop) {
          return Math.min(1, screenWidth / 1920);
        } else if (screenWidth < 750) {
          return Math.max(0.5, Math.min(1, screenWidth / 750));
        }
        return 1;
      }
      
      return parsed;
    }
    
    // Helper to read CSS variable
    function getCSSVar(name) {
      const value = getComputedStyle(section).getPropertyValue(name).trim();
      return parseFloat(value.replace('px', '')) || 0;
    }
    
    // Read position CSS variables based on viewport
    function readPositions() {
      const desktop = isDesktop();
      const suffix = desktop ? '-desktop' : '';
      const positions = {};
      
      for (let i = 1; i <= 15; i++) {
        positions[`circle${i}InitialLeft`] = getCSSVar(`--circle-${i}-initial-left${suffix}`);
        positions[`circle${i}InitialTop`] = getCSSVar(`--circle-${i}-initial-top${suffix}`);
        positions[`circle${i}InitialOpacity`] = getCSSVar(`--circle-${i}-initial-opacity${suffix}`) || 0;
        positions[`circle${i}MiddleLeft`] = getCSSVar(`--circle-${i}-middle-left${suffix}`);
        positions[`circle${i}MiddleTop`] = getCSSVar(`--circle-${i}-middle-top${suffix}`);
        positions[`circle${i}MiddleOpacity`] = getCSSVar(`--circle-${i}-middle-opacity${suffix}`) || 0;
        positions[`circle${i}EndLeft`] = getCSSVar(`--circle-${i}-end-left${suffix}`);
        positions[`circle${i}EndTop`] = getCSSVar(`--circle-${i}-end-top${suffix}`);
        positions[`circle${i}EndOpacity`] = getCSSVar(`--circle-${i}-end-opacity${suffix}`) || 0.8;
      }

      // Machine and content positions
      positions.machineInitialTop = getCSSVar(`--machine-initial-top${suffix}`) || (desktop ? 541 : 862);
      positions.machineMiddleTop = getCSSVar(`--machine-middle-top${suffix}`) || (desktop ? 440 : 771);
      positions.machineEndTop = getCSSVar(`--machine-end-top${suffix}`) || (desktop ? 366 : 771);
      positions.contentInitialTop = getCSSVar(`--content-initial-top${suffix}`) || 0;
      positions.contentMiddleTop = getCSSVar(`--content-middle-top${suffix}`) || 100;
      positions.contentEndTop = getCSSVar(`--content-end-top${suffix}`) || 100;
      positions.machineInitialLeft = 0;
      positions.machineMiddleLeft = 0;
      positions.machineEndLeft = 0;
      
      return positions;
    }
    
    let positions = readPositions();

    // Apply animation at specific progress (0-1)
    function applyAnimation(progress) {
      const scaleFactor = getScaleFactor();
      const desktop = isDesktop();
      
      // Three-stage animation
      let currentContentTop, currentContentOpacity, currentMachineTop, currentMachineLeft;
      
      if (progress <= 0.5) {
        // Stage 1 (0-50%): initial -> middle
        const stage1Progress = progress * 2;
        
        currentContentTop = positions.contentInitialTop + (positions.contentMiddleTop - positions.contentInitialTop) * stage1Progress;
        currentContentOpacity = 0.5 + (1 - 0.5) * stage1Progress;
        currentMachineTop = positions.machineInitialTop + (positions.machineMiddleTop - positions.machineInitialTop) * stage1Progress;
        currentMachineLeft = positions.machineInitialLeft + (positions.machineMiddleLeft - positions.machineInitialLeft) * stage1Progress;
        
        // Circles stage 1
        circles.forEach((circle, index) => {
          const circleNum = index + 1;
          const initialLeft = positions[`circle${circleNum}InitialLeft`];
          const initialTop = positions[`circle${circleNum}InitialTop`];
          const initialOpacity = positions[`circle${circleNum}InitialOpacity`];
          const middleLeft = positions[`circle${circleNum}MiddleLeft`];
          const middleTop = positions[`circle${circleNum}MiddleTop`];
          const middleOpacity = positions[`circle${circleNum}MiddleOpacity`];

          const currentLeft = initialLeft + (middleLeft - initialLeft) * stage1Progress;
          const currentTop = initialTop + (middleTop - initialTop) * stage1Progress;
          const currentOpacity = initialOpacity + (middleOpacity - initialOpacity) * stage1Progress;

          circle.style.left = (currentLeft * scaleFactor) + 'px';
          circle.style.top = (currentTop * scaleFactor) + 'px';
          circle.style.opacity = currentOpacity;
        });
      } else {
        // Stage 2 (50-100%): middle -> end
        const stage2Progress = (progress - 0.5) * 2;
        
        currentContentTop = positions.contentMiddleTop + (positions.contentEndTop - positions.contentMiddleTop) * stage2Progress;
        currentContentOpacity = 1;
        currentMachineTop = positions.machineMiddleTop + (positions.machineEndTop - positions.machineMiddleTop) * stage2Progress;
        currentMachineLeft = positions.machineMiddleLeft + (positions.machineEndLeft - positions.machineMiddleLeft) * stage2Progress;
        
        // Circles stage 2
        circles.forEach((circle, index) => {
          const circleNum = index + 1;
          const middleLeft = positions[`circle${circleNum}MiddleLeft`];
          const middleTop = positions[`circle${circleNum}MiddleTop`];
          const middleOpacity = positions[`circle${circleNum}MiddleOpacity`];
          const endLeft = positions[`circle${circleNum}EndLeft`];
          const endTop = positions[`circle${circleNum}EndTop`];
          const endOpacity = positions[`circle${circleNum}EndOpacity`];

          const currentLeft = middleLeft + (endLeft - middleLeft) * stage2Progress;
          const currentTop = middleTop + (endTop - middleTop) * stage2Progress;
          const currentOpacity = middleOpacity + (endOpacity - middleOpacity) * stage2Progress;

          circle.style.left = (currentLeft * scaleFactor) + 'px';
          circle.style.top = (currentTop * scaleFactor) + 'px';
          circle.style.opacity = currentOpacity;
        });
      }

      // Apply content and machine positions
      contentContainer.style.top = (currentContentTop * scaleFactor) + 'px';
      contentContainer.style.opacity = currentContentOpacity;
      machineContainer.style.top = (currentMachineTop * scaleFactor) + 'px';
      
      // Desktop: machine stays centered (no left animation)
      // Mobile: also centered via CSS
    }
    
    // Smooth animation loop using requestAnimationFrame
    function smoothAnimate() {
      // Interpolate current progress towards target progress
      const diff = targetProgress - currentProgress;
      
      // Only animate if there's a meaningful difference
      if (Math.abs(diff) > 0.001) {
        currentProgress += diff * smoothFactor;
        applyAnimation(currentProgress);
        animationFrameId = requestAnimationFrame(smoothAnimate);
      } else {
        // Snap to target when close enough
        currentProgress = targetProgress;
        applyAnimation(currentProgress);
        animationFrameId = null;
        
        // Mark as completed if reached 100%
        if (currentProgress >= 1) {
          animationCompleted = true;
        }
      }
    }
    
    // Update target progress and start animation loop if needed
    function updateProgress(progress) {
      targetProgress = Math.max(0, Math.min(1, progress));
      
      // Start animation loop if not already running
      if (animationFrameId === null) {
        animationFrameId = requestAnimationFrame(smoothAnimate);
      }
    }
    
    // Check if section is at top
    function isSectionAtTop() {
      const rect = section.getBoundingClientRect();
      return rect.top <= 0 && rect.bottom > 0;
    }
    
    // Handle wheel event (desktop)
    function handleWheel(e) {
      // If animation already completed, don't interact anymore
      if (animationCompleted) {
        return;
      }
      
      // Only lock scrolling when section is at top
      if (!isSectionAtTop()) {
        return;
      }
      
      const delta = e.deltaY;
      const newScroll = accumulatedScroll + delta;
      
      // Boundary check - unlock at edges
      if (newScroll < 0 && delta < 0) {
        // At 0%, scrolling up -> 检查是否已经在页面绝对顶部
        const pageScrollTop = window.pageYOffset || document.documentElement.scrollTop;
        
        if (pageScrollTop <= 0) {
          // 已经在页面最顶部，阻止继续向上
          e.preventDefault();
          accumulatedScroll = 0;
          updateProgress(0);
          return;
        }
        
        // 还没到页面顶部，允许向上滚动
        accumulatedScroll = 0;
        updateProgress(0);
        return;
      }
      if (newScroll > totalScrollDistance && delta > 0) {
        // At 100%, scrolling down -> unlock, allow normal page scroll down
        accumulatedScroll = totalScrollDistance;
        updateProgress(1);
        return;
      }
      
      // Within animation range -> lock scroll
      e.preventDefault();
      e.stopPropagation();
      
      // Update accumulated scroll with clamping
      accumulatedScroll = Math.max(0, Math.min(newScroll, totalScrollDistance));
      const progress = accumulatedScroll / totalScrollDistance;
      updateProgress(progress);
    }
    
    // Handle touch events (mobile)
    let touchStartY = 0;
    let touchLastY = 0;
    
    function handleTouchStart(e) {
      touchStartY = e.touches[0].clientY;
      touchLastY = touchStartY;
    }
    
    function handleTouchMove(e) {
      // If animation already completed, don't interact anymore
      if (animationCompleted) {
        return;
      }
      
      // Only lock scrolling when section is at top
      if (!isSectionAtTop()) {
        return;
      }
      
      const currentY = e.touches[0].clientY;
      const deltaY = touchLastY - currentY; // positive = down, negative = up
      
      if (deltaY === 0) {
        return;
      }
      
      const newScroll = accumulatedScroll + deltaY;
      
      // Boundary check - unlock at edges
      if (newScroll < 0 && deltaY < 0) {
        // At 0%, scrolling up -> 检查是否已经在页面绝对顶部
        const pageScrollTop = window.pageYOffset || document.documentElement.scrollTop;
        
        if (pageScrollTop <= 0) {
          // 已经在页面最顶部，阻止继续向上
          e.preventDefault();
          accumulatedScroll = 0;
          updateProgress(0);
          touchLastY = currentY;
          return;
        }
        
        // 还没到页面顶部，允许向上滚动
        accumulatedScroll = 0;
        updateProgress(0);
        touchLastY = currentY;
        return;
      }
      if (newScroll > totalScrollDistance && deltaY > 0) {
        // At 100%, scrolling down -> unlock, allow normal page scroll down
        accumulatedScroll = totalScrollDistance;
        updateProgress(1);
        touchLastY = currentY;
        return;
      }
      
      // Within animation range -> lock scroll
      e.preventDefault();
      e.stopPropagation();
      
      // Update accumulated scroll with clamping
      accumulatedScroll = Math.max(0, Math.min(newScroll, totalScrollDistance));
      const progress = accumulatedScroll / totalScrollDistance;
      updateProgress(progress);
      
      touchLastY = currentY;
    }
    
    // Handle resize
    let lastIsDesktop = isDesktop();
    function handleResize() {
      const currentIsDesktop = isDesktop();
      if (currentIsDesktop !== lastIsDesktop) {
        lastIsDesktop = currentIsDesktop;
        positions = readPositions();
      }
      
      // Reapply animation at current progress (instant, no smooth transition on resize)
      const progress = accumulatedScroll / totalScrollDistance;
      currentProgress = progress;
      targetProgress = progress;
      applyAnimation(progress);
    }

    // Listen to events
    window.addEventListener('wheel', handleWheel, { passive: false });
    window.addEventListener('touchstart', handleTouchStart, { passive: false });
    window.addEventListener('touchmove', handleTouchMove, { passive: false });
    window.addEventListener('resize', handleResize);

    // Initial state
    applyAnimation(0);
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initMoveEffect);
  } else {
    initMoveEffect();
  }
})();
</script>

{% schema %}
{
  "name": "Meraki Move Effect",
  "settings": [
    {
      "type": "textarea",
      "id": "title",
      "label": "Title",
      "default": "Streamlined Workflow\nOn Screen"
    },
    {
      "type": "textarea",
      "id": "description",
      "label": "Description",
      "default": "Start-to-finish coffee experience, with Meraki delivering a seamless workflow in every cup."
    },
    {
      "type": "image_picker",
      "id": "machine_image_desktop",
      "label": "Machine Image (Desktop)",
      "info": "Recommended: 888x1094px"
    },
    {
      "type": "image_picker",
      "id": "machine_image_mobile",
      "label": "Machine Image (Mobile)",
      "info": "Recommended: 750x655px"
    },
    {
      "type": "image_picker",
      "id": "mask_image_desktop",
      "label": "Bottom Mask (Desktop)",
      "info": "Recommended: 1920x328px"
    },
    {
      "type": "image_picker",
      "id": "mask_image_mobile",
      "label": "Bottom Mask (Mobile)",
      "info": "Recommended: 750x328px"
    }
  ],
  "presets": [
    {
      "name": "Meraki Move Effect"
    }
  ]
}
{% endschema %}
